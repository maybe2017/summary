### 生命周期
0. 窗口管理windowStage: onWindowStageCreate(打开app时创建的新窗口，可指定入口);  onWindowStageDestory();
1. 应用 UIAbility: onCreate(); onDestory(); onForeground(); onBackground()
2. 页面 被@Entry修饰的组件: onPageShow; onPageHide(页面每次隐藏时); onBackPress(用户点击返回按钮，不是路由!)
3. 组件 被@Component修饰的自定义组件: aboutToAppear(build执行之前); aboutToDisappear(自定义组件销毁之前)
4. aboutToAppear -> build -> onPageShow

### 状态管理, 组件间数据传递
1. 单向传递: 父组件@State 修饰变量, 子组件@Props引用变量(不能初始化)
2. 双向传递: 父组件@State 修饰变量, 子组件@Link引用变量(不能初始化)，传递时用$修饰变量
3. 跨级双向: 父组件@Provide 修饰变量, 子孙组件@Consume引用变量，注意变量名要一致(可以取同样的别名)!
4. 页面间传参:
    ```
    // 要引入router路由组件，通过调用 `router.pushUrl({})` 实现页面跳转
    router.pushUrl({
        url: 'pages/xxx',
        params: {}
    });
    // 接收路由params传递过来的参数
    let value = router.getParams()['key'] as string  
    ```
5. App级别: AppStorage.SetOrCreate('k','v');  AppStorage.Get('k')    
### 状态监听器
1. @State @Watch('changeFunc')同时修饰变量，当变量值变化时，changeFunc函数会被调用! (注意避免死循环!)

#### 遇到的坑
1. 如果一个触发逻辑中，同时更新多个状态变量呢？ 重新渲染组件的动作是异步的 ！！
2. 到底重新渲染了那些组件？ 底层应该也有一套虚拟dom机制，只是重新渲染与状态变量相关的组件节点！ (注意不是重新执行build方法 !!!)
3. 数组的push方法会改变原始数组，但是数组的filter方法却 `不会` 改变原始数组 !!! 所以导致@Link修饰的状态数据数组没有改变！更不会重新渲染相关组件。(其实@State是可以监听到数组增删的变化的)

### 疑问？ 重新渲染组件的动作是即刻异步的吗？是必须等当前函数逻辑执行完才开始异步处理，还是即刻异步处理？有没有可能在`当前函数逻辑执行完之前`执行？



### Row、Column组件
1. Column组件，内部的子组件，是在主轴（垂直方向）是start排列的，但是在交叉轴上（水平方向）是居中的；Row组件，则相反
2. Row与Column不会拉升，默认是靠子组件撑起。
3. 可以依靠 子组件设置layoutWeight属性，来自适应父容器剩余长度！

### Flex组件
1. 当子组件的行数、列数不确定的时候，即子组件个数不确定的时候，考虑使用Flex组件进行弹性布局！
2. Flex组件，direction排列方向参数默认是row方向。且主轴、侧轴默认均为Start, 这与Row、Column组件不同！
3. Flex组件默认在主轴方向，(不设置长度时), 在其父容器内自动撑满父容器(坑);
4. 如果direction是row，必须设置高度，考虑设置宽度(可以用百分比等分, 也可用flexGrows)；如果direction是Column，必须设置宽度，考虑设置高度。


### 布局注意点
1. 注意组件的高度尽量别写死!! 可能会出现内容实际的高度 > 给定的高度 ==> 导致其他组件内容会覆盖当前组件。。参考overflow属性, 越界就设置隐藏。
2. 需要有滚动条的组件，必须给高度!!! 不然滚动条显示不出来。
3. 子组件尽量不用设置 width:90% ，直接采用 width:100%, 要实现两侧留白效果, 给父级组件设置 padding即可!!, 需要注意的是，在父容器设置padding的情况下，子组件如果设置margin-right:20，那么字组件内容展示时，可能会越过父容器的padding区域
4. width:100%的理解，是指当前组件宽度是父容器宽度
5. height:100%的理解，是指当前组件宽度是父容器高度，而不是父容器剩下的高度！！ 如果父容器有多个组件呢？ 设置为100%的子组件就会溢出。。此时考虑设置layoutWeight(1)，使组件自适应宽高(就是父组件剩下的宽高)
6. 组件设置padding则是把内容向里挤，背景色会染上。设置margin则是把组件套个光环，背景色不会染上。

### 布局有问题时候的思考
1. 怎么思考一个组件的位置，看他的父组件是什么！父组件的默认子组件布局是什么？
2. 从外层依次向里看，行的子组件则是垂直居中，列的子组件是水平居中！！
3. 如果不想让行的子组件垂直居中，有两种方式改位置，1是子组件自身设置alignSelf，2是父容器设置alignItems
4. 子组件自身设置alignSelf,只会影响子组件自身在父容器的位置；但是父容器设置alignItems，会影响全部子组件的布局

### 父容器Row或Column组件没有设置宽高的时候
1. 对于父容器Column，子组件默认水平居中，怎么体现这个水平居中的？ 答: 如果只有一个子组件，不能体现。如果有两个，且第二个实际内容长于第一个，那么就会以第二个组件为准，第一个组件相较于第二个水平居中。因为此时第二个组件的大小就是父容器的大小 !!!