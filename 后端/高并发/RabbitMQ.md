### RabbitMQ基础【设计目标：标准化AMQP、低延迟】

#### RabbitMQ的工作模式【特点：支持复杂的路由策略】
1. 生产者消息直接发队列，多个消费者竞争消费。work queue 模式
2. 交换机 - direct模式：交换机绑定队列时，指定一个 `明确的` routing-key；那么发消息时，交换机会根据消息中routing-key来匹配并投递到具体的队列。【单条件匹配路由】
3. 交换机 - topic模式：交换机绑定队列时，指定一个 `可模糊匹配` 的routing-key；那么发消息时，交换机会根据消息中routing-key来匹配并投递到具体的队列。【单条件匹配路由】
4. 交换机 - fanout：广播模式。
5. headers路由：声明交换机、发送消息的时候，均带上一个Map类型的headers参数，参数完全匹配、或部分匹配时，才会被交换机投递到指定的队列。【多条件匹配路由】

#### RabbitMQ的队列类型
1. classic 经典队列，一个队列对应一个磁盘文件。会将消息缓存（或用时加载）到内存中。【内存压力-性能问题？】 【适合数据量较少，生产消费速度稳定，即不要让内存积压太多消息】
2. `Quorum 仲裁队列`，队列多副本（Raft），保证分布式集群环境下数据一致性，可靠性。【内存压力-性能问题？】 【适合数据安全、可延迟处理】
    ```
    在消息头部，记录了消息的重复投递次数，解决毒消息问题。
    ```
3. Stream 流式队列，以append-only方式来记录消息并持久化到文件中，（取代在内存中维护FIFO队列），通过调整消费者offset来实现消息分发。【操作系统刷盘-数据丢失？】【适合消费者多，读消息十分频繁】
    ```
    // 可以调整消费offset，即支持消息回溯，重新消费
    // 支持大批量消息积压了，因为是append-only方式写，压力也不大

    类似kafka了..
    ```

#### 使用流程
1. RabbitMQ没有太复杂的部署架构，服务端仅有Broker角色。【轻量化设计，Broker自身维护路由，不需要如NameServer的复杂服务发现机制】
    ```
    // 依赖 Erlang 分布式通信，Broker 之间通过内部协议同步元数据，无需外部 NameServer
    1. 普通集群：队列分散到不同节点，但是没有备份，队列存在单点问题。

    2. 镜像集群：队列分散到不同节点，在其他节点上存在备份，但是所有操作都是主节点（主队列）完成，然后同步给备份队列。【高可用，而非扩展性】
    
    【注意：队列中的数据是完整的，并没有像kafka那样分片】
    【主从复制系统】

    ```
2. 客户端根据部署信息获取与Broker之间的Connection连接对象（TCP长连接），再基于连接对象获取Channel通道，在通道上进行所有通信操作。
3. 在Channel上，创建交换机、队列，用routing-key关联交换机、队列。
4. 用Channel发送消息到交换机，可指定路由routing-key，让交换机将消息投递到具体队列。
5. 消费者默认用的是推模式。

#### 消息TTL + 死信队列 => 延迟队列
1. 原理：正常消息设置了 TTL，过期后且未消费，则会被标记为 `死信`。死信会被路由到指定的死信交换器（DLX），最终进入死信队列。
2. 缺点：消息A（TTL=30分钟）、消息B（TTL=10分钟）依次入队，必须等消息A先过期后，才会检测B消息。【延迟时间不准确、无法动态改延迟时间】

#### RabbitMQ怎么保证消息的顺序性呢？包括顺序投递 -> 顺序写入 -> 顺序消费这一整条链路【高并发之 - 分区顺序性】
1. 保证消息顺序性是一个涉及生产者、队列、消费者多方协作的过程，需要有明确的`限制条件`。

    ```
    // 顺序投递 【需要单线程】
    RabbitMQ 不使用 HTTP，而是基于 AMQP 协议（TCP 长连接），生产者通过 Channel 按顺序发送消息

    // 顺序写入 【需要单队列】
    队列自带FIFO特性

    // 顺序消费 【需要单线程】
    方案1：单消费者单线程消费，显式 ACK后再处理下一条消息。
    方案2：消息中嵌入序号（Sequence ID），消费者缓存并排序后处理。

    // 消费失败，直接进死信队列隔离，避免消息被重新入队打乱顺序！
    ```
2. 保证顺序性的前提下，怎么提高并发消费性能？？【分区顺序性-局部有序】

    ```
    // 在业务场景不需要 `严格全局顺序` 情况下，可实现 `分区顺序性` 来提高并发度
    // 即把业务数据分散，实现局部有序即可
    queue_index = hash(order_id) % queue_count  # 例如按订单ID哈希后模10，分配到10个队列之一
    生产者将同一订单ID的消息始终进入同一队列（如订单ID123相关的消息，永远进入队列2），那么不同订单ID相关的消息，会均匀分散到不同队列。
    

    // 对于RabbitMQ、RocketMQ，需要上面的方案实现手动分区，让消息局部有序，局部有序的消息组，分散在不同的队列中。
    // 对于Kafka，区是物理存储单元，天然支持顺序性和并行消费
    ```


#### RabbitMQ怎么保证消息不丢失？【生产者确认】
1. RabbitMQ也会将消息先写内存，然后再刷盘，所以是可能在极端情况（停电等）存在消息丢失的。
    ```
    // 解决方案：publisher confirms 推送确认机制【让生产者基于这些监听回调，自行做补救措施】
    RabbitMQ提供了回调监听器，通过这些回调监听器，构建了可靠的消息投递体系。
    （如：发送消息到broker端时，broker端会响应ack或nack，来标识消息是不是已经被broker端正常保存了），RabbitMQ提供ack与nack的监听回调

    // 异步发送 客户端监听Broker端返回结果这种方式一定是最好的吗？
    这种方式会导致生产者端，会另外启用一个线程等待Broker的确认，会加重生产者端的负担。
    ```
2. 即需要RabbitMQ服务端与客户端配合来解决。