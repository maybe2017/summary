### 操作系统层面区分的两种状态
1. 内核态：运行操作系统程序的状态，用其操作底层硬件，具有所有命令的使用权限。
2. 用户态：运行用户程序的状态；为避免用户程序能直接操作硬件，引发安全问题。【用户态下，CPU 只能执行受限的指令】


### 系统调用 -> 用户态到内核态切换  
1. 什么是系统调用？
    ```
    中断机制：用户态程序主动请求内核服务（如文件读写、网络操作等），必须通过一种机制让CPU切换到内核态。这种机制就是软中断（传统方式）或专用指令（现代方式）。
    系统调用必然涉及 `用户态 到 内核态 的切换`，但具体是否用 "中断" 取决于 CPU 架构。现代系统倾向于使用专用指令而非软中断。【通过 syscall/int 0x80 等指令】
    ```

2. 用户态代码触发系统调用后，会通过 `中断或指令` 触发上下文切换。
    ```
    // 保存现场（用户态的上下文）
    CPU及内核的中断处理程序，会保存寄存器、指令指针、栈指针等信息到内核栈（一个结构体pt_regs）

    // 为什么需要保存现场？
    因为执行内核态的程序时，也需要使用CPU寄存器，为避免覆盖用户态程序执行状态，需要先保存用户态上下文。

    // 执行用户态代码、和执行内核态程序，是同一个线程吗？
    对Java程序来说，是同一个线程，因为Java的线程和内核线程是一一对应的。
    内核的角度来看，它只认线程调度实体(Task Struct)

    线程运行Java代码时，使用用户态栈（由JVM管理）
    线程运行内核态代码时，使用内核预分配的内核栈（同一线程的内核栈是独立的，但属于同一线程）

    ```
3. 进行IO操作时，要读取的数据还没准备好，所以在内核会暂时阻塞，数据准备好了之后，是谁去唤醒这个线程？唤醒的线程会立刻执行吗？
    ```
    // 阻塞过程
    1. 线程调用阻塞式 I/O（如 read()），触发系统调用进入内核态
    2. 内核发现数据未就绪（如磁盘未返回数据、Socket 无缓存），将线程标记为 休眠状态（TASK_INTERRUPTIBLE）
    3. 线程被移出 CPU 调度队列（不再占用 CPU），进入等待队列（如磁盘 I/O 队列或 Socket 的 sk_wq）。
    
    // 关键点
    阻塞时线程仍占用内存资源，但CPU时间片被释放
    线程的 task_struct（Linux 中描述线程的结构体）保留在内核中，记录其阻塞的 I/O 事件。

    ```

    ```
    // 数据就绪后的唤醒机制
    1. 当数据就绪时（如磁盘 DMA 完成、网卡收到数据包），硬件发送 `中断信号` 给 CPU。
    2. 内核的 `中断处理程序` 快速响应，将数据拷贝到内核缓冲区（如 Socket 接收队列）。
    3. 内核调用 wake_up() 或 wake_up_interruptible() 函数，将阻塞线程从等待队列移至 可运行队列（Run Queue）


    // 唤醒的线程会立刻执行吗？
    不会，被唤醒的线程状态从 TASK_INTERRUPTIBLE 变为 TASK_RUNNING，但尚未获得 CPU，需经过调度器决策。

    ```