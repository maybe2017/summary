## 文件系统

### 一、磁盘扇区与CHS
1. CHS定位扇区：C是柱面，也是读写磁盘最耗时的阶段 `寻道时间`。
2. 为减少寻道时间，在将数据写入磁盘时，应尽量写入到同一柱面上。
	```
	1. 理想情况: 写入数据时磁头不动，柱面固定，仅盘面旋转情况下写入数据。
	2. 在某盘面的某磁道写数据时，因盘面会旋转，所以可以连续写入数据，将数据有序的存储到相邻扇区上。
	3. 当上一盘面同一磁道的扇区都存储满之后，继而保持磁头不动，用相同方式存储到下一个盘面。
	```
3. 操作系统会屏蔽计算CHS的细节，即直接让进程输入 `block盘块号`，访问到对应的扇区。

### 二、多进程通过盘块号访问磁盘[消费者 - 生产者]
1. 进程通过 `盘块号` 计算出 `起始扇区号`，向磁盘发出请求，用 `电梯算法将请求放入队列` 后，进程sleep。[为减少寻道时间]
2. 磁盘驱动程序发起中断，中断处理程序会从 `请求队列` 中消费请求，计算出 `CHS` 后进行读写处理；
3. 读取或写入处理结束后，再次进入 `硬件中断处理程序`，唤醒请求对应的进程。
4. 特别需要注意的是：读写请求都会使用 `内存缓冲区`，提高效率。
	```
	1. 读的时候，中断处理程序会先从扇区读数据到[内核态?]`内存缓冲区`，唤醒进程后，进程会从 `缓冲区` 读取。
	2. 通过一个盘块号可以一次性读取多个扇区的数据。
	```

### iNode与FD的关系
1. 每个文件对应一个inode，inode是文件的物理身份标识，存储文件元数据 和 磁盘块映射（权限、大小、时间戳、数据块位置等）【文件系统层】
	```
	struct inode {
		unsigned long i_ino;      // inode 号
		umode_t i_mode;           // 文件权限和类型
		loff_t i_size;            // 文件大小
		struct file_operations *i_fop; // 文件操作函数
		// ... 其他元数据
	};

	```

2. FD本质是内核文件表（File Table）的索引。【进程层】
	```
	// 内核文件表是什么？
	内核中用于管理进程打开文件的核心数据结构，它记录了进程与文件交互的关键状态信息（如读写偏移量、访问模式等）
	内核维护的全局表，存储 `所有进程打开文件的状态信息`
	struct file {
		struct inode    *f_inode;   // 指向文件的 inode
		loff_t          f_pos;      // 当前读写偏移量
		unsigned int    f_flags;    // 打开标志（O_RDONLY, O_WRONLY 等）
		struct file_operations *f_op; // 文件操作函数（read/write 等）
		atomic_long_t   f_count;    // 引用计数（被多少 fd 引用）
		// ... 其他字段（如锁、私有数据等）
	};



	// 总结
	1. FD 是进程操作文件的逻辑句柄，通过 内核文件表 关联到 inode。
	2. 不同进程打开同一文件时，每个进程的FD不同，指向独立的 file 结构体，且默认读写偏移量独立。
	3. fork()后，子进程继承父进程的 fd 表，指向相同的 file 结构体，会共享读写偏移量（因为 file 是内核全局资源）。
	```

### 进程中的FD与标准输入输出重定向
1. 每一个进程都默认拥有3个FD：0标准输入，1标准输出，2标准错误
2. 可以通过 FD + 输入或输出重定向符，将输入或输出的内容进行重定向到其他地方
	```
	// 1> 表示将输出流重定向
	ls /  1> ls1.txt

	// 0< 表示将ls进程原本的标准输入流 重定向到ls1.txt，让其读取ls1.txt的内容，并再将原本的标准输出流（屏幕？）重定向到ls2.txt
	ls /  0< ls1.txt 1> ls2.txt

	// 将程序的标准输出、错误等都重定向到日志文件；最后的一个&用于在后台运行命令。
	nohup java -jar xxx.jar 1> all.log 2>&1 & 

	
	// `/dev/null` 是一个特殊的设备文件，被称为"空设备"，它的主要用途是丢弃写入其中的所有数据
	// 因为运行的程序不需要从终端接收任何输入，所以可使用 `</dev/null` 关闭标准输入，避免占用终端


	// 1> 标准输出重定向 	会覆盖文件内容
	// >> 标准输出追加重定向  追加到文件末尾
	nohup java -jar xxx.jar >> all.log 2>&1 </dev/null &
	```


### 三、文件控制块[FCB = INODE(重要)]
1. 所有进程都是从父进程fork出来的，会复制父进程的PCB，进程控制块PCB中有使用到的文件描述符集合: file[fd]
	```
	// 核心
	1. 每一个file当中有inode属性，inode中维护了一张映射表：[字符流位置区间:盘块号]	
	2. file当中有一个fseek读写指针，记录当前文件的读写地址，通过它，加上读写的字节数count，就形成了 `字符流位置区间`
	3. 通过 `[字符流位置开始，位置结束]` 参数做key，就可以在inode中的索引表去定位到盘块号了。
	```

2. `连续的盘块结构` 实现文件时: 用一张映射表，记录了每个文件与盘块号的映射关系。[方便查询]
	```
	1. 文件名，起始块，占用块数
	2. 类似数组元素连续存储，访问快，但是不适合动态改变，可能有覆盖问题。
	```
3. `链表式的盘块结构`，每个块会指向下一个盘块。
4. `多级索引结构`，`索引块 - inode` 中存储了当前文件用到的所有盘块号 `映射关系 - [字符流位置区间:盘块号]`，或者以盘块为单位的二级索引。
5. Inode也会存储在盘块上，一个盘块可存储多个Inode。

### 四、目录树的生成
1. 目录也是文件，其也会抽象为inode，inode中会存储映射表[文件名:INODE指针]，或者二级索引。[均是以盘块为单位]
2. 磁盘按规范格式化后，被操作系统加载时，按顺序读取引导块、超级块，找到INode集合起始位置后，即可生成根目录，继而形成目录树。
	```
	1. 引导块
	2. 超级块，记录了INode集合状态位图、数据块集合位图 的长度等信息，可以用来定位 `INode集合部分` 的开始位置。
	3. INode集区域，存放了文件或目录的inode信息。解析出的根目录Inode会放在初始进程的PCB中，fork出子进程会复制该信息。
	4. 数据块区域
	```