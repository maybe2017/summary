## 寄存器[CPU内部的高速存储单元]

### 寄存器位数[决定CPU可以直接表示的数据范围]
1. 16位寄存器[AX，BX，CX，DX，SI，DI，SP，BP]
2. 32位程序，寄存器都是有E开头[EAX，EBX，ECX，EDX，ESI，EDI，ESP，EBP]
3. 64位程序的，寄存器都是R开头
4. 如采用32位寄存器的CPU单次计算支持的最大整数位数是32位(寄存器可以表示的最大整数值是2^32-1)


#### 指令地址寄存器[EIP]
1. 用于存储 `即将被取出并执行` 的指令的内存地址。
2. CPU会根据IAR中存储的地址，从内存中读取指令[内存控制器]，并传递给 `指令译码器` 进行解析和执行。
3. CPU根据当前指令的类型和结果来决定下一条指令的地址, 指令地址寄存器 `存储的地址` 会被更新。


#### 指令寄存器[IR]
1. 存放当前从主存储器读出的正在执行的一条指令。

#### 基址指针寄存器[EBP]
1. 指向 `栈帧底部或栈底` (栈帧底部和栈底是两个不同的概念)

#### 堆栈指针寄存器[ESP]
1. 指向 `栈帧顶部或栈顶` (栈帧顶部和栈顶是两个不同的概念)

#### 标志寄存器
1. ZF——零标志（Zero Flag）
2. CF——进位标志（Carry Flag）
3. PF——奇偶标志（Parity Flag）
4. AF——辅助进位标志（Auxiliary Carry Flag）
5. OF——溢出标志（Overflow Flag）
6. SF——符号标志（Sign Flag）

#### 段寄存器作用[存储段地址]
1. CS——代码段寄存器: 存储代码段的段地址
2. DS——数据段寄存器: 存储数据段的段地址
3. SS——堆栈段寄存器: 存储堆栈段的段地址
   ```
   1. 这里的数据段, 代码段, 栈段, 是程序员对程序内容的划分。
   2. 在汇编源程序中, 会手动标明数据段, 代码段和栈段。在高级编程语言中, 不需我们指定, 编译器编译成了汇编源文件的时, 会自动设置。
   ```

## CPU取指令

### 指令和指令集
1. 指令 = 操作码 + 0到多个操作数（源操作数，目的操作数）
2. 指令集: 某一类cpu所支持的指令集合IS（Instruction Set）。
3. 根据指令集分成R（Reduced精简）ISC（computer计算机） 和CISC（Complex复杂）。

    ```
    // 把基于8086的架构的处理器统称为x86处理器
    CISC处理器的典型代表: Intel公司的1978年推出的 8086，其后的8088 80286 80386 80486 奔腾以及AMD均兼容8086。。

    RISC处理器的典型代表: MIPS处理器，ARM处理器。
    ```


push %ebp mov %esp, %ebp

#### 常用指令
1. mov `目的操作数[寄存器/内存单元]` `源操作数[寄存器/数据/内存单元]`。[将源操作数，送入目的操作数]
2. push（字入栈）

## 程序的全局变量在编译期就确定了地址了吗？
1. 全局变量在编译期就确定了地址这句话并非完全准确, 一般的程序是这样。但动态库里面的全局变量能在编译期确定地址吗？答案是不行。
而且不是“编译时”，而是“编译期”，事实上确定地址的事情是在链接阶段才确定的。

2. 局部变量的地址, 其在函数栈帧内的布局是由编译器确定的. 而其地址当然只有运行起来之后才能确定. 因为程序开始运行时栈才开始存在。局部变量的地址分配是运行时由函数中的指令分配的。

## 为什么debug中运行程序可以设置断点之类的？
1. 因为debug时不放弃对cpu的控制。
1. 实模式: DOS系统, cpu是在实模式下的, 需要注意对内存的修改。
2. 保护模式: Windows7和Unix系统 cpu是在保护模式下的。(windows启动的时候运行的是`实模式`, 加载了操作系统以后, 就是切换到`保护模式`了)