## 段(面向用户侧)、页(面向硬件侧) 的重定位过程
1. 用户侧给出的逻辑地址: [cs:ip]表示[程序段，段的偏移量]
2. 首先根据 逻辑地址 在`段表`中查询段的基址，加上段的偏移量后，可以定位到指令在 `虚拟内存` 中的位置(虚拟地址)。
3. 再根据 `虚拟地址` 算出 `页号`、`页内偏移`，根据页号及偏移在`多级页表`中查询，得到页框地址(物理内存地址)
4. MMU硬件完成23步骤。


## 用户程序载入内存
1. 用分区算法将 `用户程序段(代码段、数据段..)` 放入 虚拟内存的某一块区域中。设置段基址且会维护 `映射关系(建立段表)`。
2. 存放段的虚拟内存，会以页为单位存储在物理内存中。 设置页基址且会维护`映射关系(多级页表)`。
3. fork子进程后，会复制父进程的页表，页表中内容也拷贝，父子进程页表不同，但页表中指向的是相同物理地址。(会设置为只读，写会触发页中断)
4. 对子进程某页存储的内容进行修改的时候，触发页中断，才会真正分配新的物理内存页，然后将物理地址覆写到子进程页表。

## 内存换入换出实现虚拟内存[swap分区管理]
1. 虚拟内存，虚拟地址空间，用户随意分配使用这4G内存地址空间。(用户侧不用关心物理内存的真实大小)
2. 运行时，才将程序从磁盘加载，根据映射关系，将虚拟地址 映射为 真实物理内存
### 页面换入[请求调页]
1. MMU硬件根据逻辑地址算出页号后，查页表时，发现缺页，会产生 `缺页中断`，中断处理程序会从磁盘上读取这一页的内容，存储到物理内存分配页空间，然后设置映射关系。
### 页面换出
1. 因为真实物理内存是有限的，并不能总是能获取新的页，所以需要选择一页换出到磁盘
2. 页面置换算法：FIFO先来先出，缺点：可能导致缺页异常多，不断的换入换出，从磁盘进行读写，慢
3. MIN算法：选择最远将使用的页换出，缺点：需要知道将来发生的事...
4. LRU算法：选择最近最少使用的页换出，特点：用过去的历史预测将来...【利用程序执行的局部性】
### LRU实现
1. 每一页维护一个时间戳，选择具有最小时间戳的页进行换出 (每执行一条指令都要覆写这个时间戳值，要处理其溢出情况，放在操作系统中不合适)
2. 页码栈，新页落在栈顶，选择栈底的页进行淘汰..(指针要移动多次，慢)
3. 循环队列，每一页维护一个标记位，1表示最近访问过，指针循环访问队列中的每一页，扫描每一页的标记位，`遇1就置0，遇0就淘汰该页`。【最近没有使用 - 近似实现】
4. 方法3由于 `局部性原理`，缺页实际会很少，那么可能扫描指针转完整一圈后(第一圈扫描时都是1)，淘汰过程会退化成FIFO...
5. 在方法3基础上，再加上一个快指针，来清除R位(使1置0) 【快慢指针 - clock算法】

## 给进程分配多少页框呢？
1. 分配很多时，页面很少换入，内存不能高效利用；
2. 进程很多时，导致每个进程分配的页框很少，那么缺页率增大，页面频繁从磁盘换入换出，进程会一直等待调页，cpu利用率降低... 【颠簸现象】
