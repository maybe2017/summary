## 进程控制块PCB
1. pcb会存储 `物理内存基址`，由于进程睡眠时会导致swap，会不停在磁盘与内存中 切入切出，导致基址会变。
2. 程序指令会在 `运行时重定位`: 根据 内存基址 + 指令偏移 找到真正的内存物理地址，cpu加载这个物理地址中的指令并执行。
   
## 进程分段 及LDT段表
1. 程序编译后的指令加载到内存前，会被分段, 分成数据段、代码段..(分散加载，高效利用内存) 
2. 段表里面有所有分段的[段标志位, 段基址]，cpu要执行某一个段里面的指令时，就会根据指令所属的段，在段表里面找到 `段基址`, 再加上指令的偏移量，定位跳转到物理内存某一个位置取指执行！
3. GDT表: 操作系统进程的段表
4. LDT表: 其他进程的段表, 也会放在PCB中。

## 内存分区、分页
1. 操作系统会维护 内存空闲分区表、已分配分区表，表中每一项记录了起始地址与使用长度；程序分段找空闲内存时，会依据此表查询。(对虚拟内存的处理)
2. 解决内存碎片 > 物理内存会分页，针对每个 `程序段` 的内存请求，系统会一页一页的分配给这个段!
3. 页表[第几页, 页面尺寸4K, 读写权限]，cpu执行某个指令时，会根据MMU找到这个指令放在哪一页及页内偏移，从而定位到物理内存中指令的位置(用页号先定位到页框号，页框号才用来计算物理内存地址)。
4. 解决单级页表太大 > 多级页表[为页表建立多级目录] + 快表[寄存器, 存储最近使用的`页号`到物理`页框`的映射]，满足了`页号连续, 且占用内存小`的条件。