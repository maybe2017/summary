### 一、原码、反码、补码

1. 二进制，最高位bit表示符号位（正负），2^8 = 256，2^7 = 128，那么8个bit只有7个bit用于表示数值，范围就只能为 -128～127。

   ```java
     // 举例 5 和 -5
     // 原码: 0000 0101； -5：1000 0101
   
     // 反码: 
     // 1. 如果是正数，反码与原码相同。
     // 2. 如果是负数，反码规则: 除符号位1外，其余bit位均取反，如-5的反码: 1111 1010
   
     // 补码:
     // 1. 如果是正数，补码与原码相同。
     // 2. 如果是负数，补码规则: 将其反码加一，那么-5的反码就是: 1111 1011
   ```

​       

2. 为什么计算机里要使用补码存储数字？

   - Cpu中无减法器，只有加法器，那么需要将所有减法运算转为加法运算。用原码、或反码进行加法计算，计算结果均不合期望值，只有补码适合。
   - 0～255内循环，以256为模的系统中，

3. 模的概念

   - 是指一个计量系统的计数范围，例如：时钟的计量范围是0~11，模=12。同样计算机也可以看成一个计量机器，因为计算机的字长是定长的，即存储和处理的位数是有限的，因此它也有一个计量范围，即都存在一个“模(mod)”。表示n位的计算机计量范围是0 ~ 2^n-1，模=2^n。
   - “模”实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的余数。
   - n位计算机，设n=8，所能表示的最大数是11111111，若再加1成100000000(9位)，但因只有8位，最高位1自然丢失（相当于丢失一个模）。又回到了 00000000，所以8位二进制系统的模为2^8 ，也就是11111111。

   

### 二、Java中用～取相反数

1. 首先必须先明白，计算机存储一个数，均是用补码存储的。那么当看到计算机中一串二进制位后，需要我们自己去计算，转为原码。

2. Java中的取反符～，是针对所有的二进制位取反，包括符号位。

3. 举例如下：

   ```java
   // 数字1的原码 0001
   // ～1  ==>>  1110 那么此时计算机里面存储的这个1110到底是什么数呢？因为存储的是补码，所以需要算
   // 此时1110是补码，那么反码就是 1101，原码就是1010(符号位不变)，则该数值就是 -2
   // 所以 ～1 = -2，
   // 所以若想获得1的相反数，则为 ～1+1 或 ～(1-1)
   ```

4. 可推导出公式:  -x = ～x+1 =  ～(x-1)