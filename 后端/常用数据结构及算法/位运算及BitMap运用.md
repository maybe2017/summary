#### 取余运算符 % 
1、25 % 10 = 5
2、当除数是2的幂时，X % 2^n  = X & (2^n - 1)
#### 取商运算符 /

25 / 10 = 2;

####  & 位与运算符   全1才1
1. 一个不为0的数 & (其取反+1) , 可得到最右侧为1的的bit位

####  | 位或运算符  有1就1


####  ^异或运算符  不同才1 
1. 相同为0，不同为1，也可以理解为: 无进位相加
2. 满足交换律与结合律；一群数的异或，结果与顺序无关。
    - 相同一个数的偶数次^结果为0；
    - 相同一个数的奇数次^结果为其本身；
3. 对于任何数，N ^ N = 0; N ^ 0 = N

    ```java
    假设:
    a = 10 , 其二进制数为: 1010
    b = 12 , 其二进制数为: 1100   ==>> 差异为中间的10
    
    // 如果a和b交换，在二进制数看来，因为第一位和最后一位相同，所以中间两位只要交换一下就行了；
    // 那么交换两个数，就是它们的二进制数不一样的位，只要各自取反(0变1，1变0)就行了
    
    // 1. 先找到不一样的bit，a = a ^ b; ==>> 0110
    // 2. 用不一样的bit再去与原始b进行取反，b = a ^ b; ==>> b就变成了a
    // 3. 用不一样的bit再与b(实际b已经是a)取反，a = a ^ b; ==>> a就变成b
    
    // 交换数组中两个索引位置的数
    // 需要注意的一点是: 在交换数组中i位置和j位置的元素时，i不能等于j，否则就是对同一块内存区域异或
    // 自己异或自己 N ^ N = 0
    private void swap(int[] arr, int i, int j) {
        // 找到不同的bit 用arr[i]记录
        arr[i] = arr[i] ^ arr[j];
        // 对arr[j]的bit序列 取反，让arr[j]变成arr[i]
        arr[j] = arr[i] ^ arr[j];
        // 对arr[i]的bit序列 取反，(此时arr[j]实际已经变成了原来的arr[i])
        arr[i] = arr[i] ^ arr[j];
    }
    
    
    // 已知int数组中，有一个数出现了奇数次，其余的数都出现了偶数次，找出这个数
    // 相同一个数 异或奇数次 的结果是其本身
    // 0 ^ N = N
    private static void testEor() {
        int i = 999;
        int j = 888;
        // i出现偶数次 j出现奇数次，结果为j
        System.out.println(i ^ i ^ j);
        // 异或满足交换律结合律，与顺序无关
        System.out.println(0 ^ i ^ j ^ i ^ j ^ i);
    }
    
    
    // 已知int数组中存储了一批数，已知有两个不同的数字出现了奇数次，其余的数都出现了偶数次，找出这两个数
    // 1. 让数组中每个数都 异或 一遍，那么偶数次的数都被抵消成了0，得到的结果就是 剩下的两个不同数的异或值，a ^ b。
    // 2. int eor = a ^ b; eor的二进制序列表示，a与b的二进制位序列中，不同的位的序列
    // 3. 很明显，因为题目是两个不同的数，那么a != b, 那么 eor二进制位序列中，必然存在至少一个bit位为1（我们取最右侧的1）
    // 4. 重点来了，光知道 异或后 的二进制位序列是没用的，两个数必须知道其中一个数的值，才能计算出另外一个数，如何计算?
    // 5. 假设eor二进制位序列中第N位bit为1，那么意味着：a与b的二进制位序列，在第N位的bit值是不一样的（一个为0，一个为1）
    // 6. 我们将数组分成两部分，一部分是二进制位序列第N位值为0的，一部分是为1的，很明显，a与b分属于这两个分组
    // 7. 现在聚焦到这两个分组，因为其他的数都出现了偶数次（所有bit都会被异或抵消为0）那么第N位为1的分组，个数必定是偶数(除开a)，那么将改组所有数进行异或，最后就得到了a
    
    
    ```

----

1、<< 左移，相当于乘以2的n次方，例如：1<<6 相当于1×64=64，3<<4 相当于3×16=48*

2、>> 右移，相当于除以2的n次方，例如：64>>3 相当于64÷8=8

3、^ 异或，相当于求余数，例如：48^32 相当于 48%32=16


##### 去重（找表示 不重复状态位01 的对应的数值）

- 20亿个整数中找出不重复的整数的个数（值也可以输出），内存不足以容纳这20亿个整数

1、2bits 对一个关键字的状态进行存储，不存在为00，存在一次01，存在两次及以上用11。
2、把这20亿个数字放进去，同样先计算数组下标和对应的位
3、如果对应的状态位为00，则将其变为01，表示存在一次；如果对应的状态位为01，则将其变为11，表示已经有一个了，即出现多次；如果为11，则对应的状态位保持不变，仍表示出现多次
4、统计状态位为01的个数，就得到了不重复的数字个数，时间复杂度为O(n)。
5、数值，就得通过数组下标与 位的下标，反向计算出来。




