
### 硬件背景
1. 现代计算机架构下，多核心CPU已经成为常态。
2. CPU的运算速度，与主内存不是一个数量级的，为了提高CPU效率，在其与主存之间，增加了多级高速缓存。（L1、L2缓存，cpu核心各自拥有，L3缓存是多个cpu核心共享）
3. 由于局部性原理，CPU让加载指令的时候，是以缓存行（64字节）为单位，从主存加载到高速缓存。

#### CPU的可见性【MESI协议 + lock前缀指令】
1. MESI表示了缓存行的四个状态：修改状态Modified、独占状态E、共享状态S、失效状态I。
2. 各核心通过监听自己使用的缓存行(或变量地址？)是否被其他核心读取，来改变缓存行的状态。
    ```
    // 想保证多核心之间的数据一致性（可见性）
    如：当自身修改了某缓存行，发现其他核心也要使用该缓存行时，就将自己的缓存行修改刷会主存，并通过某种方式让其他核心缓存行的状态置为Invalid无效。
    那么当其他核心使用其缓存行时，发现状态是Invalid，就会强制从主存重新读取。
    ```
3. 但是MESI也会有问题，导致在多核环境下，无法真正完全准确的保证数据一致性。
    ```
    1. 核心通知其他核心，让缓存行失效时，使用的是一个队列，而不是立即失效。（有延迟）
    2. 核心与高速缓存之间，还存在一个 Store Buffer，及CPU寄存器计算结束后，不是直接写回高速缓存，而是写到该缓存，其目的是提高CPU写效率。

    // 所以其实在多核环境下，CPU仍然需要一个lock指令，来保证可见性。
    如CAS指令，即cmpxchg，如果没有加锁，它在多核环境下，也是保证不了原子性的。因此，在执行它时，会在其前面加上lock指令：lock cmpxchg
    而这个指令，锁的粒度可以是总线、缓存行、北桥信号。

    // 【注意，此处指在X86架构上，是用的lock指令，其他架构上可能不一样；因此才需要JMM来屏蔽底层硬件实现内存一致性的差异，提供了对上层统一的接口来保证内存一致性的编码能力。】
    ```

#### 缓存行失效、伪共享问题
1. 共享变量：每个核心都加载了该变量的缓存行，因为彼此的修改，不同核心对应的缓存行不停的失效，导致不停的只能从主内存读取。（反而增加了多线程执行的耗时）
2. 不同变量ab，却恰巧在同一个缓存行：核心A对a的修改，却导致了核心B中缓存了b的缓存行失效。
    ```
    // 解决办法：强制使单一变量存储在一个单独的缓存行中，称为 `缓存行对齐`。
    1. 构造一个Padding父类，填充7个long型变量。
    2. 目标变量的类，继承Padding类，从而使目标类加载后，目标变量一定在单独一个缓存行。
    3. 或者在目标变量前后，分别填充7个long型变量，保证目标变量一定在单独一个缓存行。
    ```

#### CPU的有序性【内存屏障 -> 最终是lock前缀指令去保证】
1. 因为cpu执行速度很快，但是一些指令，如读内存很慢，不可能让cpu等待，此时，cpu就会检测后续的命令是否与当前的命令有依赖性，没有依赖性的话，就可以提前执行。（仅保证了单线程语义下的正确性）
2. 读命令可以乱序执行，写命令也会合并写入一个4Byte的超高速缓存combineBuffer，然后再写入L1或其他缓存。
3. 如何保证不乱序？CPU级别的内存屏障(memory fence)
    ```
    // 3种屏障类型，其实现仍然用到了 lock前缀指令
    lfence：加载屏障，放在读指令前，阻塞屏障前后的指令重排
    sfence：存储屏障，放在写指令前，阻塞屏障前后的指令重排
    mfence：全能屏障
    ```    

### JMM （JAVA内存模型）

#### 为什么需要JMM？
1. CPU硬件层面，`lock前缀指令 + cmpxchg` 实现了原子性；`lock前缀指令 + MESI协议` 实现了可见性；`lock前缀指令（内存屏障）` 实现了有序性；
2. X86架构上，是用的lock前缀指令，其他架构上可能不一样；因此才需要JMM来屏蔽底层硬件实现内存一致性的差异，提供了对上层统一的接口来保证内存一致性的编码能力。
3. 那么在X86架构上，Java并发的3大特性实现原理：
    ```
    synchronized，ReentrantLock(CAS)的原子性由 `lock前缀指令 + cmpxchg` 实现。
    volatile的可见性由 `lock前缀指令 + MESI协议` 实现。
    volatile的有序性由 `lock前缀指令（内存屏障）` 实现。
    ```