
### 一、传统JVM线程 - 平台线程(PlatformThread)
1. 传统的线程是由 `操作系统` 调度的，是操作系统线程的简单粗暴的包装，与操作系统线程为1:1的关系。缺点是内存占用大，一个线程一般都需要1M的栈空间(-Xss)，堆的部分可以共享。
2. 传统的IO密集型应用的写法，就是每一个请求-响应，就会占用一个线程，如果请求比较多，一次就要用掉1M，很快内存就会耗尽。受限于操作系统，只能创建有限的数量。
    ```
    // 线程池
    使用线程池可以缓解问题，减少了线程创建的消耗，但是无法提升线程的数量；
    
    // Reactor线程模型，异步事件驱动风格编写代码
    1. 将程序分为很多个步骤，每个步骤可能会在不同的线程中执行，不能使用如 ThreadLocal 等并发编程相关的 Api。
    2. 核心元素：事件分离器[多路复用器]，事件，事件处理器
    ```
3. 映射关系如图：![传统JVM线程](https://qn.mayu1024.com/hexo%E5%8D%9A%E5%AE%A2/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Jvm-platformThread.webp)

### 二、虚拟线程 - 由JVM自身调度的线程
1. 虚拟线程是建立在平台线程之上的，一个平台线程可以对应多个虚拟线程，一个平台线程还是一一对应内核线程的。
2. 虚拟线程占用的内存只有十几个字节，在IO的时候，它可以把阻塞的线程，改为虚拟线程，并把正在执行虚拟线程的操作系统线程（也就是carrier thread，执行线程）腾出来，去做其他操作，这样多次请求就能 `共享操作系统线程`，提高了IO密集型系统请求的吞吐量。
3. 虚拟线程，它自带了stack也是虚拟的，JVM会调节这个stack的大小，因为是有栈的，所以它的适用范围更广，简单说就是可以完全模拟线程。
4. 映射关系如图：![虚拟线程](https://qn.mayu1024.com/hexo%E5%8D%9A%E5%AE%A2/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Jdk19-virtualThread.webp)

### 三、总结
1. 通过虚拟线程技术，程序的内存占用会大幅降低，IO密集型应用，如各种web servers，都可以在同等硬件条件下，大幅提升io的吞吐量。
2. 既然virtual thread的创建、释放、调度成本低，调度完全在用户态进行，官方不建议池化。