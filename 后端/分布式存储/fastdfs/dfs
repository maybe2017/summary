首先从下载安装说起吧。fastdfs的四个相关:运行库、主程序、java客户端、nginx的fdfs插件，如果找不到地方下载的话其实都可以直接在github上下载，下载下来是源码的zip文件不是tar也没关系的。文件名最后边的-master是指下载下来的这个包是目前的“主程序版本”。在linux中使用unzip解压了就可以用(也是先编译make再安装make install)，如果没有执行权限就chmod给个权限就可以。虽然版本和老师不一样，起码算是有个可用的。

然后说说tracker、storage和带着插件的nginx。tracker服务器相对于其他两个比较独立，tracker服务器是不依赖nginx的，而storage服务器如果没装带插件的nginx服务器则无法提供文件访问。整体的流程是客户端提交请求给tracker，要求获取一个合适的storage，然后客户端直接去找对应的storage的服务器，在其nginx服务器的引导下访问storage中的文件。

用户上传文件的时候，不带参数地向tracker请求一个文件上传服务器，此时会按照tracker.conf中配置的策略去提供一个storage(或轮询，或指定，或按剩余存储空间)以供上传。而请求下载或更新(删除)文件的时候，是要带group以及filename参数的，这样才能从tracker中一定获取到可用的storage，否则拿错了storage服务器是不能完成预期的


客户端: 只访问入口服务器，只能提供对某文件的简略信息。
入口反向代理服务器(Nginx): 只负责负载均衡，引导用户访问上游服务器集群中的一台。
upstream服务器集群(tomcat等web服务器，包含与其协同的远程服务提供者、静态资源服务器Nginx以及数据库服务器集群): 能够根据用户提供的文件简略信息查询数据库获取对应的具体信息(group和remote_filename)。有fdfs-client依赖，配置了tracker服务器的地址，可以向其发送带有文件具体信息的请求来获取能够提供这个文件服务的storage服务器的地址;  或是向tracker提出上传文件需求并获得storage地址。得到的storage地址将直接返回给客户端。
tracker服务器: 无需nginx支持，只需要开放22122端口，配置提供storage的策略。storage和WEB服务器都会主动来找它。
从属于不同group的storage服务器: 依赖于带着插件的nginx，直接与拿着地址过来找的客户端对接，完成文件相关服务。与tracker对接，相当于在其中注册自己以备选择。storage所在的服务器要开放23000等其自己的端口。
我觉得最后一段主要的大问题是配置mod_fastdfs.conf的时候。每个storage所在的服务器的nginx插件只需要配置自己所对应的storage的信息即可。mod_fastdfs.conf中最后的group_count参数和后续的【group1】【group2】是用于配置【同一台物理服务器上存在多个storage】的，而不是用于配置多台物理服务器上总的storage数量的。没出错的原因是每台机器上确实只运行了一个storage，nginx只当额外配置的那个storage挂掉了。(同时，如果你配置了后边的这个多group，前面配置的组、端口、存储位置等属性就失效了。你可以试试将前面的配置都注释掉，依然能运行。)


首先明确两个要点:1、如果你想访问指定group里的文件，就要在向tracker发出请求的时候选择带有group名参数的方法，这样子tracker才会给你提供正确的storage。2、入口nginx和storage服务器上的nginx作用是不同的，入口nginx是引导你轮询访问应用服务器，应用服务器才是fastDFS的真正使用者，storage服务器上的nginx只用于你直接用浏览器访问它时直接返回文件，装不装影响不大，不装，应用服务器也可以通过java的fastDFS Client来访问文件


在上一个回复的两个要点的基础上，你用nginx访问的不是fastdfs集群，而是应用服务器集群，也就是给你提供页面服务，在后台调用fastdfs client与tracker和storage的服务器，它们这些服务器可以访问tracker提供的storage且不需要storage安装有nginx服务器。只要你正确地设计了应用服务器，它们就应该在调用文件的时候指定group，这样就不存在调用到没有对应文件的storage的问题了。这个教程里老师讲的是有漏洞的，当存在多个group时是不能仅靠文件名来获取文件的。



上传调度服务
(1)根据用户申请上传的文件判断是否秒传；
(2)根据用户所在ip及worker节点状态返回上传接口地址



前面也已经讲过，断点续传的功能是基于分块上传来实现的，把一个大文件分成很多个小块，服务端能够把每个上传成功的分块都落地下来，客户端在上传文件开始时调用接口快速验证，条件选择跳过某个分块。

实现原理，就是在每个文件上传前，就获取到文件MD5取值，在上传文件前调用接口（/index/checkFileMd5，没错也是秒传的检验接口）如果获取的文件状态是未完成，则返回所有的还没上传的分块的编号，然后前端进行条件筛算出哪些没上传的分块，然后进行上传。

当接收到文件块后就可以直接写入到服务器的文件中

这是文件夹上传完后的效果