
### 可达性分析 - 判别垃圾 - GC Roots
1. 以GC Roots为根，向下可标记出在引用链上的所有对象，那么不在引用链上的对象都为垃圾。
    ```
    1. Java虚拟机栈、或本地方法栈里面的 `局部变量表`；
    2. 类的静态变量、或常量 `引用的对象`；
    3. 一些异常对象等
    ```
2. 可达性分析算法，`枚举GC Roots` 时就会 `STW`，需要在一个 `一致性快照` 上进行分析。


### 分代GC策略
1. 一般年轻代采用 `复制算法`，因为存活对象少，复制不会花费太多时间。 存活(eden + to) -> from区。
2. 老年代采用 `标记-压缩` 算法，因为存活对象多，且一般很长一段时间才会进行GC。

### 并行GC、并发GC回收器
1. 串行GC，`serial gc`，STW内单线程GC，适合单核CPU，无线程切换。
2. 并行GC回收器：`parallel gc` 或 `parNew gc`，STW内有多条GC线程来进行GC，适合多核CPU，*吞吐量高*。
3. 
4. 并发GC回收器：STW被分散，用户线程几乎不停止，GC线程与用户线程同时进行，*延迟低*。 
    ```
    // CMS标记清除，会产生内存碎片
    // 空闲列表 - 大对象分配时可能失败concurrent modle fail -> serial old 进行Full GC - 很慢
    1. 初始标记：STW很短，仅标记GC Roots(局部变量表)直接关联的对象，不用递归去管嵌套对象。
    2. 并发标记：从GC Roots开始遍历内存整个对象图并标记；很耗时，因为没有STW，与用户线程同时执行，所以可能标记前后的数据不一致。
    3. 重新标记：STW，修正第二步可能出现的错误（可达变成了不可达）。
    4. 并发清理：耗时，清除垃圾。

    // 二者不能同时满足
    1. 吞吐量高：0.2 + 0.2 = 0.4，单位时间内GC频率低，但是单次GC时间多些。[程序运行快]
    2. 低延迟：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5, 单位时间内GC时间少，但总和多些。[用户体验]

    // JVM调优标准
    保证高吞吐量优先条件下，尽量减少单次GC的STW。

    // G1 垃圾回收器，针对内存比较大的服务端程序，兼顾了吞吐量与STW
    1. 回收阶段STW，时多个GC线程并行(吞吐量)，且不会完全阻塞用户线程(低延迟)。
    2. 

    ```

### 对象引用 - 强软弱虚
1. 强
2. 软：JVM内存空间不足的时候，才会回收。
3. 弱：发现后就立即GC回收。
    ```
    // Thread里面的`ThreadLocalMap<<WeakRefrence> key，value>`
    1. 当仅仅当前Map对象引用了这个弱引用的 key对象时，gc后，这个key对象就会被回收。
    2. map里面的value不会被回收，就产生了<null, value>的键值对，在调用get、set、remove方法时会自动清空key为null的k-v。
    ``` 
 