## OOM问题排查

### 一、outOfMemeryError: java dump space

#### 一般原因
1. 代码中存在过多 `大对象` 的分配；很可能是大数组对象；
2. 可能存在内存泄漏，导致在多次GC后，还是无法找到一块连续的空间分配给当前对象；

#### 解决方案
1. 先检查代码，是否存在 `大对象` 的分配；
2. 通过jmap，把当前堆内存dump下来，使用 `jvisualvm`,`MAT` 工具分析一下，检查是否存在内存泄漏；
3. 如果真的是内存不够，用参数 -xmx 加大内存

### 二、outOfMemeryError: GC overhead limit exceeded

#### 定义
1. 这是一个 `预判性异常`，抛出该异常的时候系统没有真正的内存溢出!!!
2. 定义：98%的时间都在GC，但是仅回收了不到2%的内存。。

#### 一般原因
1. 可能有一些对象不断的新增，但是却GC不掉，比如循环中添加String.intern()；不停的向堆中常量池放对象，大但是因为被引用却不能及时回收。


### 三、outOfMemeryError: Metaspace

#### 元空间(非堆)存储的什么？
1. 虚拟机加载的类信息、常量、JIT即时编译器编译后的代码数据
2. 检查是否存在大量反射生成类的操作

### 四、unable to create new native thread

#### 一般原因
1. 很明显，创建了大量的线程导致的。
2. JVM创建线程Thread的时候，会让操作系统也创建一个线程，使用的是系统的内存，而不是JVM的。
