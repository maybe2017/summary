
### IO多路复用
1. 多个socketChannel可以注册到一个selector上，同时针对每一个socket还可以指明感兴趣的事件。这是Java层面Nio对io多路复用的实现。
2. 操作系统层面，本质是select poll epoll 系统调用函数


### select、poll、epool系统调用
1. select 与poll 要来回拷贝fdset，遍历寻找已经准备就绪的fd。
2. epoll 通过回调机制将就绪的fd 放入双向链表，用户进程不需要再遍历。

### Reactor编程模型
1. 单selector单线程，连接及读者事件均自己处理。
2. 单selector多线程，读写事件用线程池处理。
3. 多selector多线程，连接用一个selector，读写事件用线程池，每一个线程分配一个selector。
    ```
    // 适用场景
    主要是处理高并发场景下的网络IO，使用户程序不是真正阻塞在IO操作上，仅是阻塞在等待内核准备好数据等待信号的select、poll、epool系统调用上。待数据准备好之后，用户程序再通过 `recvfrom系统调用` 从内核向用户空间拷贝数据。

    // 缺点
    如果客户端数量不多，并发量不大，可能效率不如直接使用阻塞IO，即直接阻塞在recvfrom系统调用上。
    ```


### mmap
1. IO过程分两阶段：1. 等待内核有数据准备好的信号 2.从内核空间复制到用户空间；
2. mmap是将物理内存映射到虚拟内存，用户进程操作虚拟内存即可。从磁盘读的时候，少了从内核复制到用户空间步骤，写入磁盘的时候，少了从用户空间拷贝到内核空间的步骤。