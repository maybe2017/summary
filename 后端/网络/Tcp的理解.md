### 三次握手
1. 客户端发送SYN请求，随机产生一个seq = J，客户端进入SYN_SENT状态，等待服务端确认；
2. 服务端响应SYN + ACK(J+1), seq=k; 服务端进入SYN_RCVD状态
3. 客户端再次响应ACK(k+1); 彼此验证ack后，客户端和服务端进入ESTABLISHED状态

#### 为什么是三次？而不是二次？
1. TCP是可靠的传输控制协议，而三次握手是保证数据可靠传输又能提高传输效率的最小次数。
2. 三次握手的过程是通信双方互相告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤；
3. 如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号得不到确认



### 四次挥手
1. 客户端向服务端发送一个FIN数据包（FIN =1,seq = u）主动断开连接；客户端处于FIN_WAIT1状态；
2. 服务端向客户端响应确认包（ACK = 1,ack = u+1）；此时服务端处于CLOSE_WAIT状态，客户端处于FIN_WAIT2状态；
3. 服务端向客户端发送FIN数据包(FIN = 1,seq = w)，以及确认包(ACK = 1,ack = u+1)，用来停止向客户端发送数据；
    ```
    1. 这个动作是告诉客户端：我的数据也发送完了，不再给你发数据了；
    2. 此时服务端处于LAST_ACK状态，客户端处于 `TIME_WAIT` 状态；
    3. `TIME_WAIT` 状态的客户端仍然可以接收服务端传过来的报文；
    ```
4. 客户端收到FIN数据包之后，发送一个(ACK =1,ack = w+1)报文应答
   ```
   1. 此时客户端处理TIME_WAIT状态；
   2. 需要过了一定时间（2MSL）以后，确保发送方的ACK可以到达接收方，防止已失效连接请求报文段出现在此连接中；
   ```

#### 为啥需要4次挥手？
1. 因为 TCP 是全双工的，双方需要独立关闭自己的数据流
    ```
    1. 客户端先发 FIN，表示“我不再发数据了”。
    2. 服务端先回 ACK，表示“我知道你要关了”，但可能还有数据要发。 【服务端CLOSE_WAIT状态：收到客户端关闭报文，但是自己还没有close】
    3. 等服务端数据发完，再发 FIN，表示“我也要关了”。
    4. 客户端最后回 ACK，确保服务端能正确关闭  【客户端TIME_WAIT状态，持续60s】
    ```

#### TIME_WAIT状态 【TCP 的容错机制】
1. 什么阶段出现的？
    ```
    // 四次挥手的最后一个阶段：客户端ACK 服务端的关闭连接请求（服务器说[FIN]：我数据已经发完，我也要关了）。

    这个客户端响应ACK 可能丢失，服务端虽然检测不到，但是它收不到响应会进行`超时重传`，即重新发送FIN请求（我数据已经发完，我也要关了）
    那么如果客户端还在 TIME_WAIT 状态等待（60s），就能再次回复 ACK，期望服务端能正确关闭。
    ```
2. 会出现在哪一端？
    ```
    // 【谁主动关闭连接（先发 FIN），谁就会进入 TIME_WAIT 状态】
    1. 在 客户端-服务端模型 中，通常客户端主动断开，所以客户端 TIME_WAIT 多 

    // 【被动关闭的一方（收到 FIN 后发 ACK）会进入 CLOSE_WAIT，然后发 FIN 进入 LAST_ACK】
    2. 但在 服务端主动断开 的场景（如 HTTP 短连接、负载均衡踢连接），服务端也会积累 TIME_WAIT
    ```

3. TIME_WAIT 状态的作用？
    ```
    // 进入TIME_WAIT状态后，会默认等待2MSL（60s）的时间，为啥？？
    （尽量？）确保当前连接上的所有旧数据包可以因为超时而被丢弃，防止一种特殊情况：新连接（建立与当前连接相同5元组）可能收到旧连接的 FIN 或数据包（超时的，很久才到达的）

    // 尽量确保服务端收到 最后第四次挥手的 ACK，收到后服务器端 就可以安心关闭了。
    ```
4. 如果在 `高并发短连接` 场景（如Nginx类的HTTP服务），服务器上 TIME_WAIT 过多怎么办？ 
    ```
    // 复用 TIME_WAIT 连接
    # 允许复用 TIME_WAIT 连接（适用于客户端/服务器） 【常用】
    sysctl -w net.ipv4.tcp_tw_reuse=1
    # 快速回收 TIME_WAIT（谨慎使用，可能影响 NAT 环境）
    sysctl -w net.ipv4.tcp_tw_recycle=1
    # 减少 TIME_WAIT 等待时间（默认 60s，可改为 30s）
    sysctl -w net.ipv4.tcp_fin_timeout=30

    // 避免短连接频繁创建：使用连接池或长连接
    ```


###  半连接问题

#### 什么是TCP半连接？
1. TCP半连接是指连接的一方（客户端或服务端）认为连接仍处于活跃状态，但另一方已实际失效（崩溃、网络中断、未正常关闭），导致双方状态不一致。此时，连接既不能正常通信，也未完全释放资源。【单向活跃、资源未释放】
2. 怎么导致的？
    ```
    1. 网络分区：网络单向中断（如客户端能发数据，但收不到响应）。
    2. 进程崩溃: 
        服务端崩溃：服务端进程突然终止，未发送FIN包，客户端仍保持连接
        客户端崩溃：客户端异常退出，服务端未检测到断开（如未启用TCP Keepalive）
    3. 配置不当:
        心跳超时不对称：客户端心跳间隔（30秒） > 服务端超时时间（10秒），服务端主动关闭连接后，客户端仍发送心跳。
        长连接无保活：未启用TCP Keepalive或应用层心跳，无法检测静默中断。
    ```

#### 客户端连接服务端时，出现max_connections错误，可能的原因？
1. 服务端问题？客户端发起了关闭连接请求，服务端收到了，但是却未close连接，或者负载过高close不及时？
    ```
    // 资源泄漏：服务端可能积累大量半连接，耗尽文件描述符或内存（如Linux默认限制1024个文件描述符）

    # 查看服务端半连接（Linux）
    ss -s | grep -i "half-open"

    # 常见于服务端半连接，如果存在大量，可能是 `服务端未正确关闭连接` ，`服务端负载过高，无法及时处理连接关闭请求`
    netstat -antp | grep -i "close_wait"      
    ```
2. 客户端问题？一直新建连接，但是却没有关闭？（客户端异常断开，如崩溃、被kill、断电、未发送FIN）总之 `服务端未收到客户端的FIN请求` ..
    ```
    // 导致服务端仍维护连接


    ```
3. 网络问题？（如防火墙丢弃包，但未通知TCP层）
4. 未启用TCP Keepalive或应用层心跳检测？心跳间隔设置过长（如30分钟），无法及时检测故障。连接长期闲置，但未被清理。


#### 解决方案
1. 启用TCP Keepalive及应用层心跳检测
2. 确保服务端、客户端所有连接显式关闭（捕获异常后主动关闭）
3. 限制单个IP的连接数（防御客户端恶意攻击，只不停的创建连接，不传数据）
4. nginx超时设置
    ```
    # Nginx配置
    proxy_connect_timeout 5s;
    proxy_timeout 60s;

    
    # Nginx示例：超时后直接RST连接 【复位包】
    reset_timedout_connection on;
    // Nginx 检测到某连接在 keepalive_timeout 时间内无活动（如 HTTP 请求完成后客户端不发送新请求）。跳过四次挥手，立即释放连接资源（避免 TIME_WAIT 状态）。
    // 高频短连接场景下，默认关闭方式会导致服务端积累大量 TIME_WAIT 连接，耗尽端口或文件描述符
    // 快速释放连接，适合每秒处理数千请求的服务器。【牺牲部分兼容性，接收方会立即释放连接，不保证数据完整性】
    ```

#### 疑问：服务端主动关闭了连接的话，就会清除这个连接有关的socket吧？为啥服务端连接数还会一直增加？
1. 服务端资源释放延迟：服务端主动关闭连接后，Socket会进入TIME_WAIT状态（默认保留60秒，防止旧数据包干扰新连接）。若短时间内大量关闭连接，会导致TIME_WAIT连接占用资源
    ```
    // 现象
    netstat显示大量TIME_WAIT或CLOSE_WAIT状态的连接。
    服务端连接数接近 ulimit -n限制，新连接被拒绝。
    ```
2. 客户端未正确处理关闭事件：如未监听Socket错误或未实现重连逻辑 
    ```
    客户端使用长连接池，当连接因超时被服务端关闭后：
        客户端未检测到连接死亡（如未捕获异常）。
        连接池未移除失效连接，继续分配给业务代码使用。
        业务代码发送数据失败后，重建连接，但旧连接未被清理。【一直不停的创建新连接】

    客户端会出现日志：
    Connection reset by peer（服务端已关闭连接）
    Timeout while waiting for response（客户端未收到关闭通知）。

    ```   