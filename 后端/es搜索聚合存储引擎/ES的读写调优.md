
### 前言

1. 鱼与熊掌不可兼得，要想提高并发写入效率，那么就不可避免会降低 写入实时性。
2. 写入调优是建立在写入原理之上的，写入调优以提升 `写入吞吐量`及`并发能力`为目标。


### 写入调优

    ```
    // 业务场景
    高频低量：高频的创建、更新索引文档，但数据量不会太大。一般发生在C端场景下？
    低频高量：如定期重建索引，或大批量更新文档等操作。
    ```

#### 增加Flush的时间间隔
1. Flush操作很消耗资源
2. 可以减少 Segment 、TransLog 从OSCache向Disk fsync的频率

#### 减少Segment-merge的频率
1. 增大 refresh_interval 的值，但是需要配合 Memory Buffer 参数，因为即使增大了refresh_interval，当Memory Buffer被写满了的时候，不会等待refresh_interval，而会马上形成Segment。【建议值30s】
2. 增大 Memory Buffer的值。

    ```
    减少Segment-merge的频率造成的后果：Segment被置为open状态时间置后，即降低了搜索的实时性。
    ```

#### 暂停分片副本
1. 当需要单次写入大量数据的时候，为提高写入速度，可以先关闭分片副本，写入完毕后，再开启副本。

#### 禁用Swap
1. 避免将内存页交换到磁盘存储，它可能导致GC从秒级到分钟级，或节点响应缓慢与集群断开链接等情况。




### 检索调优

#### 若非必要，可用filter代替query
1. query查询会计算查询条件 与文档的相关度，会计算得分
2. filter仅计算当前文档是否与查询条件相符合，且filter有缓存机制，可以提高查询效率。

#### 查询条件尽量使用keyword类型
1. 对于term查询，如果不需要范围查询，keyword比Integer性能更好。

#### 避免单次查询召回大量数据
1. ES擅长从海量数据中，单次召回少量高相关度的文档；【分页-> 深度分页】
2. 如果有单次查询上万数据这种需求，可以使用滚动查询

#### 深度分页
1. 设计上避免深度分页
2. max_results_window参数默认值为10000，如果不顾后果将该值调大，可能会导致服务频繁OOM不可用
3. 如果有深度分页的需求，可以采用 滚动查询 或Search After

#### 批量查询
1. 批量查询的阈值，需要在单个分片上进行基准测试，第一次查100，第二次查200，继而400，800，当查询耗时趋于平稳时，就得到该集群中最佳批量查询阈值。
2. 太大的批量请求，会使集群内存承受压力，需要避免每个请求超过几十M字节。（C端请求数较多）

#### 避免使用script脚本
1. script脚本用于复杂场景下自定义查询，但是性能较DSL差，非必要情况，尽量使用DSL解决。
2. 如果一定要用script脚本，尽量使用参数化查询。避免多次编译。

#### 给OSCache留足够的内存
1. 因为 Segment 会从ES JVM 先写入到OSCache，再从OSCache fsync 到 磁盘上，需要耗用大量内存。
2. 一般建议64G物理机，30G配置给ES JVM，即JVM占用不超过物理机内存的一半。