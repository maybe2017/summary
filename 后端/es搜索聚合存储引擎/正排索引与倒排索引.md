## 一、常用字段类型
1. 字符串string
    ```
    1. keyword, 需要精确值查询, 支持过滤、排序、聚合。如id字段。
    2. text, 但一个字段需要被全文搜索时, 生成倒排索引前, 字段值会被分词为一个个的词项term。该类型不用于排序, 也很少用于聚合, 所以默认禁用了正排索引的生成！[代价大] 
    3. 如字段既需要全文搜索, 又需要聚合与排序, 那么text与keyword都需要在该字段中存在。
    ```
2. date时间类型

## 二、性能-内存
1. es大量基于OS cache进行缓存与提升性能, 不建议使用Jvm内存进行缓存, 可能导致gc及omm问题。
2. 官方建议64G内存服务器, 16G给Jvm, 留给OS cache更大的内存, 来提升doc_value和倒排索引的缓存及查询效率。

## 三、正排索引
1. 目的: 为了term项的 `高效聚合`
2. mapping中对字段 `开启生成正排索引` 的关键词: doc_values, 默认值为true[一些type如`text`默认为不支持]
3. 对默认不支持生成正排索引的字段类型，如text类型, 需要生成正排索引时, 采用 `fileddata:true`, 但是这会使用Jvm内存。
    ```
    "tags": {
        "type" : "text",
        // 关闭生成倒排索引
        "index" : "false",
        // 关闭生成正排索引
        "doc_values" : false 
    }
    ```

## 四、倒排索引
1. 目的: 为了term项的 `高效查询`
2. 结构: 每一个term项对应一个postingList, postingList中装了 `包含这个term项的所有docId`[已排序]

### 压缩postingList中docIds的算法

#### FOR(farme of reference)
1. 特征: 稠密数据集, 已排序。
2. 因为稠密型的数据集, 其差值必然也很小, 可以用更少的bit存储, 从而取代每一个数都用int存储。
3. 实现核心: 计算相邻数据间的`差值`, 将 `差值list` 按数值大小适当分组[数值相近的存放为一组][每组的信息都会用一个字节去保存记为flag]。
  
#### RBM([roaring_array[index], xxxContainer])
1. 特征: 稀疏数据集, 已排序。
2. 稀疏型的数据集, 其差值可能会很大, 就不能采用FOR算法了。此时采用除法!
3. 因为docId为int类型, 最大为2^31, [规定除数为2^16], 那么 `商和余数` 都会小于2^16, 即65535。那么商可采用short[]进行存储。余数则需要分如下情况:
    ```
    1. 需要存储的个数 <= 4096时, 采用 `ArrayContainer[short类型存储每一个余数]`, 4096 * 2字节 / 1024 = 8kb; 即占用空间大小与存储数字个数呈线性正比。
    2. 需要存储的个数 > 4096时, 采用 `BitMap`, 用其存储值在4097~65535间的余数, 无论有多少个数, 都需要长度为65536个bit, 65536 / 8 / 1024 = 8kb; 即8kb是一个临界值。
    3. 如果余数集恰巧是连续的, 采用 `RunContainer`, 即记录[最小值, 最大值]信息。
    ```